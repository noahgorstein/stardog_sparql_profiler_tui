import re
from rich.style import Style
from rich.text import Text
from textual.widgets.tree import TreeNode
from textual.widgets import Tree
from typing import List
from widgets.utils import is_pipeline_breaker, parse_memory_string


def sum_wall_time(node: "PlanNode") -> int:
    """Utility to sum the wall time of a PlanNode's children"""
    if node.num_children == 0:
        return 0

    total_time = 0
    for child in node.children:
        child_time = child.time_ms or 0  # Consider None as 0
        total_time += child_time + sum_wall_time(node=child)

    return total_time


class PlanNode:
    def __init__(self, plan_node_dict: dict):
        """Initializes a PlanNode object with the provided dict"""
        self._label = plan_node_dict.get("label")
        self._cardinality = plan_node_dict.get("cardinality")
        self._results = plan_node_dict.get("results")
        self._time_ms = plan_node_dict.get("time", "0")
        self._memory = plan_node_dict.get("memory")
        self._gaps = plan_node_dict.get("gaps", False)
        self._children = [
            PlanNode(plan_node_dict=child_plan_node)
            for child_plan_node in plan_node_dict.get("children", [])
        ]

    @property
    def label(self) -> str:
        """A human-readable label for the operator"""
        return str(self._label) if self._label else ""

    @property
    def cardinality(self) -> int | None:
        """estimated cardinality of the plan node, i.e. how many
        solutions Stardog expects this operator to produce when the
        query is evaluated.
        """
        return int(self._cardinality) if self._cardinality else 0

    @property
    def results(self) -> int | None:
        """The number of intermediate query results generated by the plan node"""
        return int(self._results) if self._results else None

    @property
    def gaps(self) -> bool:
        """Returns True if the plan node's results is skipped else returns False

        See https://docs.stardog.com/operating-stardog/database-administration/managing-query-performance#skipping-intermediate-results
        """
        return bool(self._gaps) if self._gaps else False

    @property
    def memory(self) -> str | None:
        """Returns the total amount of allocated managed memory by the plan node

        Example: '1.8K' representing 1.8 kilobytes

        Note: use 'memory_as_bytes' to get this value converted to its bytes representation
        """
        return str(self._memory) if self._memory else None

    @property
    def time_ms(self) -> int:
        """wall time (how long the plan node took to execute on the server side)
        in milliseconds for the plan node
        """
        return int(self._time_ms) if self._time_ms else 0

    @property
    def children(self) -> List["PlanNode"]:
        """The direct child PlanNodes of the plan node"""
        return self._children

    @property
    def num_children(self) -> int:
        """The number of direct children of the plan node"""
        return len(self._children)

    @property
    def memory_as_bytes(self) -> int:
        """The total amount of allocated managed memory by the plan node as bytes"""
        try:
            if isinstance(self._memory, str):
                num_bytes = parse_memory_string(self._memory)
            else:
                raise Exception
        except :
            num_bytes = 0
        return num_bytes


class PlanNodeTree(Tree[PlanNode]):
    def __init__(self, query_plan: dict, namespaces: dict, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.query_plan = query_plan
        self.namespaces = namespaces

    def set_profiler_stats(self, profiler_stats: dict):
        self.total_memory = profiler_stats.get("memory")
        self.time = int(profiler_stats.get("time", 0))
        self.time_unit = profiler_stats.get("time unit")
        self.results = profiler_stats.get("results")

        if self.time_unit == "s":
            self.time_ms = self.time * 1000
        elif self.time_unit == "m":
            self.time_ms = self.time * 60 * 1000
        else:
            self.time_ms = self.time

    def render_label(
        self, node: TreeNode[PlanNode], base_style: Style, style: Style
    ) -> Text:

        if not node.data:
            return Text()

        existing_label = node.data.label

        # sometimes, 'label' attribute from the returned JSON from
        # Stardog includes results, wall time, etc all in the same string
        # we need to just get the part before results
        match = re.search(r"^(.*?)\s*,\s*results", existing_label)
        if match:
            label = match.group(1)
            node.set_label(label)

        node_label = Text()
        if is_pipeline_breaker(existing_label):
            node_label.append("ðŸ’¥")

        if isinstance(node.label, Text):
            node_label.append(node.label.copy())
        else:
            node_label.append(node.label)

        for prefix, uri in self.namespaces.items():
            node_label = Text(str(node_label.copy()).replace(uri, f"{prefix}:"))

        if node.data:
            if node.data.cardinality:
                node_label.append(
                    text=Text(f" [#{str(node.data.cardinality)}]", style="bold blue")
                )

            if node.data.memory:
                # TODO: error handling
                if self.total_memory:
                    pct = (
                        node.data.memory_as_bytes
                        / parse_memory_string(self.total_memory)
                        * 100.0
                    )
                    node_label.append(
                        text=Text(
                            f" {{total={node.data.memory} {pct:.2f}%}}",
                            style="bold magenta",
                        )
                    )

            if node.data.results:
                node_label.append(text=Text(", "))
                node_label.append(
                    text=Text(f"results: {str(node.data.results)}", style="bold red")
                )
                if node.data.gaps:
                    node_label.append(text=Text(" (with gaps)", style="italic red"))

            if hasattr(node.data, "time_ms") and hasattr(self, "time_ms"):
                node_label.append(text=Text(", "))
                pct = (node.data.time_ms / self.time_ms) * 100.0
                node_label.append(
                    text=Text(
                        f"wall time: {str(node.data.time_ms)}ms ({pct:.2f}%)",
                        style="bold green",
                    )
                )
            if not node.is_expanded and len(node.children) != 0:
                text = f"ðŸ‘¶ wall time {str(sum_wall_time(node.data))} ms"
                if isinstance(node.label, Text):
                    node_label.append(", ")
                    node_label.append(text=Text(text=text, style="bold slate_blue1"))

        node_label.stylize(style)

        if node._allow_expand:
            prefix = (
                "â–¼ " if node.is_expanded else "â–¶ ",
                base_style,
            )
        else:
            prefix = ("", base_style)

        return_text = Text.assemble(prefix, node_label)
        return return_text

    def build(self, query_plan: dict):
        self.query_plan = query_plan
        p = PlanNode(self.query_plan)
        build_tree(self, plan_node=p)


def build_tree(tree_node: TreeNode | PlanNodeTree, plan_node: PlanNode):
    if len(plan_node.children) == 0:
        if isinstance(tree_node, PlanNodeTree):
            tree_node.root.add_leaf(label=plan_node.label, data=plan_node)
        else:
            tree_node.add_leaf(label=plan_node.label, data=plan_node)
        return

    for child_plan_node in plan_node.children:
        if isinstance(tree_node, PlanNodeTree):
            if len(child_plan_node.children) != 0:
                tree_node = tree_node.root.add(
                    label=child_plan_node.label,
                    data=child_plan_node,
                )
                build_tree(tree_node=tree_node, plan_node=child_plan_node)
            else:
                build_tree(tree_node=tree_node, plan_node=child_plan_node)
        else:
            if len(child_plan_node.children) != 0:
                tree = tree_node.add(
                    label=child_plan_node.label,
                    data=child_plan_node,
                )
                build_tree(tree_node=tree, plan_node=child_plan_node)
            else:
                build_tree(tree_node=tree_node, plan_node=child_plan_node)
